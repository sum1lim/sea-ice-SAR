#!/usr/bin/env python3
import argparse
from math import sqrt, ceil, floor
import sys
import numpy as np

from tensorflow.keras import Input, Model, Sequential, losses
from tensorflow.keras.layers import (
    Conv2D,
    Conv2DTranspose,
    ZeroPadding2D,
    Cropping2D,
)
from sea_ice_SAR.ML_tools import process_data


class CAE(Model):
    def __init__(self, input_dimension, padding_size):
        super(CAE, self).__init__()
        self.encoder = Sequential(
            [
                Input(shape=(input_dimension, input_dimension, 1)),
                ZeroPadding2D(
                    (
                        (floor(padding_size), ceil(padding_size)),
                        (floor(padding_size), ceil(padding_size)),
                    )
                ),
                Conv2D(16, (3, 3), activation="relu", padding="same", strides=2),
                Conv2D(8, (3, 3), activation="relu", padding="same", strides=2),
            ]
        )

        self.decoder = Sequential(
            [
                Input(shape=(3, 3, 8)),
                Conv2DTranspose(
                    8, kernel_size=3, strides=2, activation="relu", padding="same"
                ),
                Conv2DTranspose(
                    16, kernel_size=3, strides=2, activation="relu", padding="same"
                ),
                Conv2D(1, kernel_size=(3, 3), activation="sigmoid", padding="same"),
                Cropping2D(
                    (
                        (floor(padding_size), ceil(padding_size)),
                        (floor(padding_size), ceil(padding_size)),
                    )
                ),
            ]
        )

    def call(self, x):
        encoded = self.encoder(x)
        decoded = self.decoder(encoded)
        return decoded


def main(args):
    X_tr, _ = process_data(f"{args.tr_dir}/{args.filename}.csv")
    X_te, _ = process_data(f"{args.te_dir}/{args.filename}.csv")

    input_dimension = sqrt(X_tr.shape[1])
    if int(input_dimension) != input_dimension:
        print("Window should be square", file=sys.stderr)
        sys.exit(1)
    elif int(input_dimension) != sqrt(X_te.shape[1]):
        print("Different train and test sample dimensions", file=sys.stderr)
        sys.exit(1)
    else:
        input_dimension = int(input_dimension)

    X_tr = np.asarray(
        [
            [
                sample[i * input_dimension : (i + 1) * input_dimension]
                for i in range(input_dimension)
            ]
            for sample in X_tr
        ]
    )
    X_te = np.asarray(
        [
            [
                sample[i * input_dimension : (i + 1) * input_dimension]
                for i in range(input_dimension)
            ]
            for sample in X_te
        ]
    )

    X_tr = np.reshape(X_tr, (len(X_tr), input_dimension, input_dimension, 1))
    X_te = np.reshape(X_te, (len(X_te), input_dimension, input_dimension, 1))

    if input_dimension > 12:
        print("Input dimension too big", file=sys.stderr)
    padding_size = (12 - input_dimension) / 2

    autoencoder = CAE(input_dimension, padding_size)
    autoencoder.compile(optimizer="adam", loss=losses.MeanSquaredError())
    autoencoder.encoder.summary()
    autoencoder.decoder.summary()

    encoded_te = autoencoder.encoder(X_te)
    decoded_te = autoencoder.decoder(encoded_te)
    print(f"Performance (mean error): {np.mean(X_te - decoded_te)}")


if __name__ == "__main__":
    parser = argparse.ArgumentParser()

    parser.add_argument(
        "--tr-dir",
        type=str,
        help="Source directory containing training datasets",
    )
    parser.add_argument(
        "--te-dir",
        type=str,
        help="Source directory containing test datasets",
    )
    parser.add_argument(
        "--filename",
        type=str,
        help="Dataset filename",
    )

    args = parser.parse_args()
    main(args)
